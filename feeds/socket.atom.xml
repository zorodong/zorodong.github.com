<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>zorodong's Blog</title><link href="%3Chttp://zorodong.github.io%3E/" rel="alternate"></link><link href="%3Chttp://zorodong.github.io%3E/feeds/socket.atom.xml" rel="self"></link><id>&lt;http://zorodong.github.io&gt;/</id><updated>2015-07-02T00:00:00+08:00</updated><entry><title>网络编程几点疑惑说明</title><link href="%3Chttp://zorodong.github.io%3E/wang-luo-bian-cheng-ji-dian-yi-huo-shuo-ming.html" rel="alternate"></link><updated>2015-07-02T00:00:00+08:00</updated><author><name>zorodong</name></author><id>tag:,2015-07-02:&lt;http://zorodong.github.io&gt;/wang-luo-bian-cheng-ji-dian-yi-huo-shuo-ming.html</id><summary type="html">&lt;h3&gt;proactor reactor 比较两者区别在于真正的读取和写入有谁来完成&lt;/h3&gt;
&lt;h4&gt;reactor：应用程序需要自己读取或者写入数据&lt;/h4&gt;
&lt;h4&gt;proactor：应用程序不需要自己进行实际的读写过程，它只需要传递缓存区给操作系统，操作系统会读取或者写入&lt;/h4&gt;
&lt;h3&gt;关于同步异步io的说明，还是参照unix编程中的比较清晰：&lt;/h3&gt;
&lt;h4&gt;同步IO操作 导致请求进程阻塞，直到IO操作完成&lt;/h4&gt;
&lt;h4&gt;异步IO操作 不导致请求进程阻塞&lt;/h4&gt;
&lt;h4&gt;根据上述定义：阻塞IO模型，非阻塞IO模型，IO复用模型和信号驱动IO模型都是同步IO模型，因为其中真正的IO操作都将阻塞进程，只有异步IO模型与POSIX定义的异步IO相匹配&lt;/h4&gt;</summary><category term="socket"></category></entry></feed>